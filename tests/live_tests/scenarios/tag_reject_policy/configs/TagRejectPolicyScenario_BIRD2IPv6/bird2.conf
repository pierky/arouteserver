
router id 192.0.2.2;
define rs_as = 999;

log "/var/log/bird.log" all;
log syslog all;
debug protocols { states, routes, filters, interfaces, events };

timeformat base         iso long;
timeformat log          iso long;
timeformat protocol     iso long;
timeformat route        iso long;

protocol device {};

ipv4 table master4 sorted;
ipv6 table master6 sorted;




# ---------------------------------------------------------
# RPKI

roa4 table RPKI4;
roa6 table RPKI6;
protocol static {
    roa4 { table RPKI4; };
    route 101.3.0.0/16 max 24 as 105;
    route 101.2.0.0/17 max 17 as 101;
    route 101.2.128.0/17 max 24 as 101;
    route 101.0.128.0/20 max 23 as 101;
    route 101.0.8.0/24 max 24 as 101;
    route 101.0.9.0/24 max 24 as 102;
    route 222.1.1.0/24 max 24 as 333;
}
protocol static {
    roa6 { table RPKI6; };
    route 3101:3::/32 max 48 as 105;
    route 3101:0:8000::/33 max 34 as 101;
    route 3101:2:8000::/33 max 48 as 101;
    route 3101:2::/33 max 33 as 101;
    route 3101:0:8::/48 max 48 as 101;
    route 3101:0:9::/48 max 48 as 102;
    route 3222:0:1::/48 max 48 as 333;
}



# ---------------------------------------------------------
# IRRDB

# AS222, used_by client AS222_1, client AS222_2
# no origin ASNs found for AS222

# no IPv4 prefixes found for AS222
# no IPv6 prefixes found for AS222

# AS2, used_by client AS2_1, client AS2_2
# no origin ASNs found for AS2

# no IPv4 prefixes found for AS2
# no IPv6 prefixes found for AS2

# AS-AS1, AS-AS1_CUSTOMERS, used_by client AS1_1, client AS1_2, client AS1_3, client AS1_4
define AS_SET_AS_AS1_AS_AS1_CUSTOMERS_asns = [
	1, 101
];

# no IPv4 prefixes found for AS_AS1_AS_AS1_CUSTOMERS
define AS_SET_AS_AS1_AS_AS1_CUSTOMERS_prefixes_6 = [
	2a01::/32{32,128}, 	2a99::/16{16,128}, 	3101::/32{32,128}
];

# AS-AS2, AS-AS2_CUSTOMERS, used_by client AS2_1, client AS2_2
define AS_SET_AS_AS2_AS_AS2_CUSTOMERS_asns = [
	2, 101
];

# no IPv4 prefixes found for AS_AS2_AS_AS2_CUSTOMERS
define AS_SET_AS_AS2_AS_AS2_CUSTOMERS_prefixes_6 = [
	2a02::/32{32,128}, 	3101::/32{32,128}
];

# WHITE_LIST_AS1_2, used_by client AS1_2 white list
define AS_SET_WHITE_LIST_AS1_2_asns = [
	1011
];

define AS_SET_WHITE_LIST_AS1_2_prefixes_4 = [
	11.1.0.0/16{16,32}
];
define AS_SET_WHITE_LIST_AS1_2_prefixes_6 = [
	2a11:1::/32{32,128}
];

# AS151866, used_by client AS151866_1, client AS151866_2
# no origin ASNs found for AS151866

# no IPv4 prefixes found for AS151866
# no IPv6 prefixes found for AS151866

# AS-AS222, used_by client AS222_1, client AS222_2
# no origin ASNs found for AS_AS222

# no IPv4 prefixes found for AS_AS222
# no IPv6 prefixes found for AS_AS222

# AS1, used_by client AS1_1, client AS1_2, client AS1_3, client AS1_4
# no origin ASNs found for AS1

# no IPv4 prefixes found for AS1
# no IPv6 prefixes found for AS1

# WHITE_LIST_AS1_1, used_by client AS1_1 white list
define AS_SET_WHITE_LIST_AS1_1_asns = [
	1011
];

define AS_SET_WHITE_LIST_AS1_1_prefixes_4 = [
	11.1.0.0/16{16,32}
];
define AS_SET_WHITE_LIST_AS1_1_prefixes_6 = [
	2a11:1::/32{32,128}
];





# ---------------------------------------------------------
# COMMON

# Get the 16bit value used to represent a peer with a 32bit ASN.
# Return 0 if no mapping exists for the peer.
function get_16bit_mapped_asn(int asn_32_bit) -> int {
	case asn_32_bit {
		151866: return 64512;
	}
	return 0;
}

# This function returns True if 'net' is a bogon prefix
# or falls within a bogon prefix.
function prefix_is_bogon() -> bool
prefix set bogons_4;
prefix set bogons_6;
{
	bogons_4 = [
		# Default route
		0.0.0.0/0,

		# IANA - Local Identification
		0.0.0.0/8{8,32},

		# RFC 1918 - Private Use
		10.0.0.0/8{8,32},

		# IANA - Loopback
		127.0.0.0/8{8,32},

		# RFC 3927 - Link Local
		169.254.0.0/16{16,32},

		# RFC 1918 - Private Use
		172.16.0.0/12{12,32},

		# RFC 5737 - TEST-NET-1
		192.0.2.0/24{24,32},

		# RFC 3068 - 6to4 prefix
		192.88.99.0/24{24,32},

		# RFC 1918 - Private Use
		192.168.0.0/16{16,32},

		# RFC 2544 - Network Interconnect Device Benchmark Testing
		198.18.0.0/15{15,32},

		# RFC 5737 - TEST-NET-2
		198.51.100.0/24{24,32},

		# RFC 5737 - TEST-NET-3
		203.0.113.0/24{24,32},

		# RFC 5771 - Multcast (formerly Class D)
		224.0.0.0/3{3,32},

		# RFC 6598 - Shared Address Space
		100.64.0.0/10{10,32}
	];
	bogons_6 = [
		# Default route
		::/0,

		# loopback, unspecified, v4-mapped
		::/8{8,128},

		# RFC 6052 - IPv4-IPv6 Translation
		64:ff9b::/96{96,128},

		# RFC 6666 - reserved for Discard-Only Address Block
		100::/8{8,128},

		# RFC 4048 - Reserved by IETF
		200::/7{7,128},

		# RFC 4291 - Reserved by IETF
		400::/6{6,128},

		# RFC 4291 - Reserved by IETF
		800::/5{5,128},

		# RFC 4291 - Reserved by IETF
		1000::/4{4,128},

		# RFC 4380 - Teredo prefix
		2001::/33{33,128},

		# RFC 4380 - Teredo prefix
		2001:0:8000::/33{33,128},

		# RFC 5180 - Benchmarking
		2001:2::/48{48,128},

		# RFC 7450 - Automatic Multicast Tunneling
		2001:3::/32{32,128},

		# RFC 4843 - Deprecated ORCHID
		2001:10::/28{28,128},

		# RFC 7343 - ORCHIDv2
		2001:20::/28{28,128},

		# RFC 3849 - NON-ROUTABLE range to be used for documentation purpose
		2001:db8::/32{32,128},

		# RFC 3068 - 6to4 prefix
		2002::/16{16,128},

		# RFC 5156 - used for the 6bone but was returned
		3ffe::/16{16,128},

		# RFC 4291 - Reserved by IETF
		4000::/3{3,128},

		# RFC 5156 - used for the 6bone but was returned
		5f00::/8{8,128},

		# RFC 4291 - Reserved by IETF
		6000::/3{3,128},

		# RFC 4291 - Reserved by IETF
		8000::/3{3,128},

		# RFC 4291 - Reserved by IETF
		a000::/3{3,128},

		# RFC 4291 - Reserved by IETF
		c000::/3{3,128},

		# RFC 4291 - Reserved by IETF
		e000::/4{4,128},

		# RFC 4291 - Reserved by IETF
		f000::/5{5,128},

		# RFC 4291 - Reserved by IETF
		f800::/6{6,128},

		# RFC 4193 - Unique Local Unicast
		fc00::/7{7,128},

		# RFC 4291 - Link Local Unicast
		fe80::/10{10,128},

		# RFC 4291 - Reserved by IETF
		fec0::/10{10,128},

		# RFC 4291 - Multicast
		ff00::/8{8,128}
	];

	if net.type = NET_IP4 then
		if net ~ bogons_4 then return true;
	if net.type = NET_IP6 then
		if net ~ bogons_6 then return true;
	return false;
}

# This function returns True if 'net' falls within a
# prefix contained in the global blacklist (for example,
# local networks)
function prefix_is_in_global_blacklist() -> bool
prefix set global_blacklist_4;
prefix set global_blacklist_6;
{
	global_blacklist_4 = [
		# Local network
		192.0.2.0/24{24,32}
	];

	if net.type = NET_IP4 then
		if net ~ global_blacklist_4 then return true;

	global_blacklist_6 = [
		# Local network
		2001:db8::/32{32,128}
	];

	if net.type = NET_IP6 then
		if net ~ global_blacklist_6 then return true;

	return false;
}

# This function returns True if the length of 'net' prefix
# falls within the range 'min'-'max' (included).
function prefix_len_is_valid (int pref_len_min; int pref_len_max) -> bool {
	if net.len < pref_len_min then return false;
	if net.len > pref_len_max then return false;
	return true;
}

# This function returns True if the AS_PATH contains one or
# more private/reserved ASN.
function as_path_contains_invalid_asn() -> bool
int set invalid_asns;
{
	# http://www.iana.org/assignments/as-numbers/as-numbers.xhtml
	invalid_asns = [
		# 16-bit
		0,			# Reserved. RFC7607
		23456,			# AS_TRANS. RFC6793
		64496..64511,		# Reserved for use in documentation and sample code. RFC5398
		64512..65534,		# Reserved for Private Use. RFC6996
		65535,			# Reserved. RFC7300

		# 32-bit
		65536..65551,		# Reserved for use in documentation and sample code. RFC5398
		65552..131071,		# Reserved.
		4200000000..4294967294, # Reserved for Private Use. [RFC6996]
		4294967295		# Reserved. RFC7300
	];
	return bgp_path ~ invalid_asns;
}

# This function returns the RTT measured for the peer given in client_ip.
# If the RTT is not available it returns 0.
function get_peer_rtt(ip client_ip) -> int {
	case client_ip {
	}

	return 0;
}

# This function scrubs BGP communities used by the route server
# for signaling purpose toward its clients. (RFC7454, Section 11)
# It must be applied on routes entering the route server.
function scrub_communities_in()
int mapped_16bit_asn;
{
	# origin_not_present_in_as_set
	bgp_community.delete([(65530, 0)]);
	bgp_large_community.delete([(999, 65530, 0)]);

	# origin_present_in_as_set
	bgp_community.delete([(65530, 1)]);
	bgp_large_community.delete([(999, 65530, 1)]);

	# prefix_validated_via_arin_whois_db_dump
	bgp_community.delete([(65530, 3)]);
	bgp_large_community.delete([(999, 65530, 3)]);

	# prefix_validated_via_rpki_roas
	bgp_community.delete([(65530, 2)]);
	bgp_large_community.delete([(999, 65530, 2)]);

	# rpki_bgp_origin_validation_not_performed
	bgp_community.delete([(65530, 4)]);
	bgp_large_community.delete([(999, 65530, 4)]);

	# reject_cause
	bgp_community.delete([(65520, *)]);

	# reject_cause_map_6
	bgp_large_community.delete([(999, 1101, 7)]);

	# rejected_route_announced_by
	bgp_community.delete([(65524, *)]);
	bgp_ext_community.delete([(rt, 65524, *)]);

}

# This function scrubs BGP communities used by clients to instruct
# the route server to perform some actions.
# It must be applied on routes leaving the route server.
function scrub_communities_out()
int mapped_16bit_asn;
{
	# add_noadvertise_to_any
	bgp_community.delete([(65508, 999)]);
	bgp_large_community.delete([(999, 65508, 999)]);
	bgp_ext_community.delete([(rt, 65508, 999)]);

	# add_noadvertise_to_peer
	bgp_community.delete([(65510, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 151866
	bgp_community.delete([(65510, 64512)]);
	bgp_large_community.delete([(999, 65510, 1..64511)]);
	bgp_large_community.delete([(999, 65510, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 65510, 1..64511)]);
	bgp_ext_community.delete([(rt, 65510, 131072..4199999999)]);

	# add_noexport_to_any
	bgp_community.delete([(65507, 999)]);
	bgp_large_community.delete([(999, 65507, 999)]);
	bgp_ext_community.delete([(rt, 65507, 999)]);

	# add_noexport_to_peer
	bgp_community.delete([(65509, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 151866
	bgp_community.delete([(65509, 64512)]);
	bgp_large_community.delete([(999, 65509, 1..64511)]);
	bgp_large_community.delete([(999, 65509, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 65509, 1..64511)]);
	bgp_ext_community.delete([(rt, 65509, 131072..4199999999)]);

	# announce_to_peer
	bgp_community.delete([(65501, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 151866
	bgp_community.delete([(65501, 64512)]);
	bgp_large_community.delete([(999, 65501, 1..64511)]);
	bgp_large_community.delete([(999, 65501, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 65501, 1..64511)]);
	bgp_ext_community.delete([(rt, 65501, 131072..4199999999)]);

	# announce_to_peers_with_rtt_higher_than
	bgp_community.delete([(64533, *)]);
	bgp_large_community.delete([(999, 64533, *)]);
	bgp_ext_community.delete([(rt, 64533, *)]);

	# announce_to_peers_with_rtt_lower_than
	bgp_community.delete([(64532, *)]);
	bgp_large_community.delete([(999, 64532, *)]);
	bgp_ext_community.delete([(rt, 64532, *)]);

	# blackholing
	bgp_community.delete([(65534, 0)]);
	bgp_large_community.delete([(65534, 0, 0)]);

	# do_not_announce_to_any
	bgp_community.delete([(0, 999)]);
	bgp_large_community.delete([(999, 0, 999)]);
	bgp_ext_community.delete([(rt, 0, 999)]);

	# do_not_announce_to_peer
	bgp_community.delete([(0, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 151866
	bgp_community.delete([(0, 64512)]);
	bgp_large_community.delete([(999, 0, 1..64511)]);
	bgp_large_community.delete([(999, 0, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 0, 1..64511)]);
	bgp_ext_community.delete([(rt, 0, 131072..4199999999)]);

	# do_not_announce_to_peers_with_rtt_higher_than
	bgp_community.delete([(64531, *)]);
	bgp_large_community.delete([(999, 64531, *)]);
	bgp_ext_community.delete([(rt, 64531, *)]);

	# do_not_announce_to_peers_with_rtt_lower_than
	bgp_community.delete([(64530, *)]);
	bgp_large_community.delete([(999, 64530, *)]);
	bgp_ext_community.delete([(rt, 64530, *)]);

	# prepend_once_to_any
	bgp_community.delete([(65521, 65521)]);
	bgp_large_community.delete([(999, 65521, 65521)]);
	bgp_ext_community.delete([(rt, 65521, 65521)]);

	# prepend_once_to_peer
	bgp_community.delete([(65521, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 151866
	bgp_community.delete([(65521, 64512)]);
	bgp_large_community.delete([(999, 65521, 1..64511)]);
	bgp_large_community.delete([(999, 65521, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 65521, 1..64511)]);
	bgp_ext_community.delete([(rt, 65521, 131072..4199999999)]);

	# prepend_once_to_peers_with_rtt_higher_than
	bgp_community.delete([(64537, *)]);
	bgp_large_community.delete([(999, 64537, *)]);
	bgp_ext_community.delete([(rt, 64537, *)]);

	# prepend_once_to_peers_with_rtt_lower_than
	bgp_community.delete([(64534, *)]);
	bgp_large_community.delete([(999, 64534, *)]);
	bgp_ext_community.delete([(rt, 64534, *)]);

	# prepend_thrice_to_any
	bgp_community.delete([(65523, 65523)]);
	bgp_large_community.delete([(999, 65523, 65523)]);
	bgp_ext_community.delete([(rt, 65523, 65523)]);

	# prepend_thrice_to_peer
	bgp_community.delete([(65523, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 151866
	bgp_community.delete([(65523, 64512)]);
	bgp_large_community.delete([(999, 65523, 1..64511)]);
	bgp_large_community.delete([(999, 65523, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 65523, 1..64511)]);
	bgp_ext_community.delete([(rt, 65523, 131072..4199999999)]);

	# prepend_thrice_to_peers_with_rtt_higher_than
	bgp_community.delete([(64539, *)]);
	bgp_large_community.delete([(999, 64539, *)]);
	bgp_ext_community.delete([(rt, 64539, *)]);

	# prepend_thrice_to_peers_with_rtt_lower_than
	bgp_community.delete([(64536, *)]);
	bgp_large_community.delete([(999, 64536, *)]);
	bgp_ext_community.delete([(rt, 64536, *)]);

	# prepend_twice_to_any
	bgp_community.delete([(65522, 65522)]);
	bgp_large_community.delete([(999, 65522, 65522)]);
	bgp_ext_community.delete([(rt, 65522, 65522)]);

	# prepend_twice_to_peer
	bgp_community.delete([(65522, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 151866
	bgp_community.delete([(65522, 64512)]);
	bgp_large_community.delete([(999, 65522, 1..64511)]);
	bgp_large_community.delete([(999, 65522, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 65522, 1..64511)]);
	bgp_ext_community.delete([(rt, 65522, 131072..4199999999)]);

	# prepend_twice_to_peers_with_rtt_higher_than
	bgp_community.delete([(64538, *)]);
	bgp_large_community.delete([(999, 64538, *)]);
	bgp_ext_community.delete([(rt, 64538, *)]);

	# prepend_twice_to_peers_with_rtt_lower_than
	bgp_community.delete([(64535, *)]);
	bgp_large_community.delete([(999, 64535, *)]);
	bgp_ext_community.delete([(rt, 64535, *)]);

	# reject_cause
	bgp_community.delete([(65520, *)]);

	# reject_cause_map_6
	bgp_large_community.delete([(999, 1101, 7)]);

	# rejected_route_announced_by
	bgp_community.delete([(65524, *)]);
	bgp_ext_community.delete([(rt, 65524, *)]);

}

# This function verifies if the route is tagged with one of
# the blackhole filtering communities.
function is_blackhole_filtering_request() -> bool
int mapped_16bit_asn;
{
	if net.type = NET_IP4 then {
	if (65535, 666) ~ bgp_community then
		return true;

	if (65534, 0) ~ bgp_community then
		return true;
	if (65534, 0, 0) ~ bgp_large_community then
		return true;

	}
	if net.type = NET_IP6 then {
	if (65535, 666) ~ bgp_community then
		return true;

	if (65534, 0) ~ bgp_community then
		return true;
	if (65534, 0, 0) ~ bgp_large_community then
		return true;

	}
	return false;
}

# This function must be applied to outgoing routes.
# It applies the blackhole filtering policy to the current route.
function apply_blackhole_filtering_policy() {
	if net.type = NET_IP4 then {

	# Configured policy: rewrite-next-hop
	bgp_community.add((65535, 666));
	bgp_next_hop = 192.0.2.66;
	# NO_EXPORT
	bgp_community.add((65535, 65281));

	}
	if net.type = NET_IP6 then {

	# Configured policy: rewrite-next-hop
	bgp_community.add((65535, 666));
	bgp_next_hop = 2001:db8:1:1::66;
	# NO_EXPORT
	bgp_community.add((65535, 65281));

	}
}

# This function verifies if the current route can be announced to
# the given client on the basis of the attached control BGP
# communities.
function route_can_be_announced_to(int peer_as; ip client_ip; string client_id) -> bool
int client_rtt;
int mapped_16bit_asn;
{
	# do_not_announce_to_peer
	if peer_as <= 65535 then {
		if (0, peer_as) ~ bgp_community then
			return false;
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (0, mapped_16bit_asn) ~ bgp_community then
				return false;
		}
	}
	if (999, 0, peer_as) ~ bgp_large_community then
		return false;
	if (rt, 0, peer_as) ~ bgp_ext_community then
		return false;

	# announce_to_peer
	if peer_as <= 65535 then {
		if (65501, peer_as) ~ bgp_community then
			return true;
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (65501, mapped_16bit_asn) ~ bgp_community then
				return true;
		}
	}
	if (999, 65501, peer_as) ~ bgp_large_community then
		return true;
	if (rt, 65501, peer_as) ~ bgp_ext_community then
		return true;

	client_rtt = get_peer_rtt(client_ip);

	if client_rtt > 0 then {
		# do_not_announce_to_peers_with_rtt_higher_than

		# 5 ms
		if (64531, 5) ~ bgp_community then
			{ if client_rtt > 5 then
			return false; }
		if (999, 64531, 5) ~ bgp_large_community then
			{ if client_rtt > 5 then
			return false; }
		if (rt, 64531, 5) ~ bgp_ext_community then
			{ if client_rtt > 5 then
			return false; }

		# 10 ms
		if (64531, 10) ~ bgp_community then
			{ if client_rtt > 10 then
			return false; }
		if (999, 64531, 10) ~ bgp_large_community then
			{ if client_rtt > 10 then
			return false; }
		if (rt, 64531, 10) ~ bgp_ext_community then
			{ if client_rtt > 10 then
			return false; }

		# 15 ms
		if (64531, 15) ~ bgp_community then
			{ if client_rtt > 15 then
			return false; }
		if (999, 64531, 15) ~ bgp_large_community then
			{ if client_rtt > 15 then
			return false; }
		if (rt, 64531, 15) ~ bgp_ext_community then
			{ if client_rtt > 15 then
			return false; }

		# 20 ms
		if (64531, 20) ~ bgp_community then
			{ if client_rtt > 20 then
			return false; }
		if (999, 64531, 20) ~ bgp_large_community then
			{ if client_rtt > 20 then
			return false; }
		if (rt, 64531, 20) ~ bgp_ext_community then
			{ if client_rtt > 20 then
			return false; }

		# 30 ms
		if (64531, 30) ~ bgp_community then
			{ if client_rtt > 30 then
			return false; }
		if (999, 64531, 30) ~ bgp_large_community then
			{ if client_rtt > 30 then
			return false; }
		if (rt, 64531, 30) ~ bgp_ext_community then
			{ if client_rtt > 30 then
			return false; }

		# 50 ms
		if (64531, 50) ~ bgp_community then
			{ if client_rtt > 50 then
			return false; }
		if (999, 64531, 50) ~ bgp_large_community then
			{ if client_rtt > 50 then
			return false; }
		if (rt, 64531, 50) ~ bgp_ext_community then
			{ if client_rtt > 50 then
			return false; }

		# 100 ms
		if (64531, 100) ~ bgp_community then
			{ if client_rtt > 100 then
			return false; }
		if (999, 64531, 100) ~ bgp_large_community then
			{ if client_rtt > 100 then
			return false; }
		if (rt, 64531, 100) ~ bgp_ext_community then
			{ if client_rtt > 100 then
			return false; }

		# 200 ms
		if (64531, 200) ~ bgp_community then
			{ if client_rtt > 200 then
			return false; }
		if (999, 64531, 200) ~ bgp_large_community then
			{ if client_rtt > 200 then
			return false; }
		if (rt, 64531, 200) ~ bgp_ext_community then
			{ if client_rtt > 200 then
			return false; }

		# 500 ms
		if (64531, 500) ~ bgp_community then
			{ if client_rtt > 500 then
			return false; }
		if (999, 64531, 500) ~ bgp_large_community then
			{ if client_rtt > 500 then
			return false; }
		if (rt, 64531, 500) ~ bgp_ext_community then
			{ if client_rtt > 500 then
			return false; }


		# do_not_announce_to_peers_with_rtt_lower_than

		# 5 ms
		if (64530, 5) ~ bgp_community then
			{ if client_rtt <= 5 then
			return false; }
		if (999, 64530, 5) ~ bgp_large_community then
			{ if client_rtt <= 5 then
			return false; }
		if (rt, 64530, 5) ~ bgp_ext_community then
			{ if client_rtt <= 5 then
			return false; }

		# 10 ms
		if (64530, 10) ~ bgp_community then
			{ if client_rtt <= 10 then
			return false; }
		if (999, 64530, 10) ~ bgp_large_community then
			{ if client_rtt <= 10 then
			return false; }
		if (rt, 64530, 10) ~ bgp_ext_community then
			{ if client_rtt <= 10 then
			return false; }

		# 15 ms
		if (64530, 15) ~ bgp_community then
			{ if client_rtt <= 15 then
			return false; }
		if (999, 64530, 15) ~ bgp_large_community then
			{ if client_rtt <= 15 then
			return false; }
		if (rt, 64530, 15) ~ bgp_ext_community then
			{ if client_rtt <= 15 then
			return false; }

		# 20 ms
		if (64530, 20) ~ bgp_community then
			{ if client_rtt <= 20 then
			return false; }
		if (999, 64530, 20) ~ bgp_large_community then
			{ if client_rtt <= 20 then
			return false; }
		if (rt, 64530, 20) ~ bgp_ext_community then
			{ if client_rtt <= 20 then
			return false; }

		# 30 ms
		if (64530, 30) ~ bgp_community then
			{ if client_rtt <= 30 then
			return false; }
		if (999, 64530, 30) ~ bgp_large_community then
			{ if client_rtt <= 30 then
			return false; }
		if (rt, 64530, 30) ~ bgp_ext_community then
			{ if client_rtt <= 30 then
			return false; }

		# 50 ms
		if (64530, 50) ~ bgp_community then
			{ if client_rtt <= 50 then
			return false; }
		if (999, 64530, 50) ~ bgp_large_community then
			{ if client_rtt <= 50 then
			return false; }
		if (rt, 64530, 50) ~ bgp_ext_community then
			{ if client_rtt <= 50 then
			return false; }

		# 100 ms
		if (64530, 100) ~ bgp_community then
			{ if client_rtt <= 100 then
			return false; }
		if (999, 64530, 100) ~ bgp_large_community then
			{ if client_rtt <= 100 then
			return false; }
		if (rt, 64530, 100) ~ bgp_ext_community then
			{ if client_rtt <= 100 then
			return false; }

		# 200 ms
		if (64530, 200) ~ bgp_community then
			{ if client_rtt <= 200 then
			return false; }
		if (999, 64530, 200) ~ bgp_large_community then
			{ if client_rtt <= 200 then
			return false; }
		if (rt, 64530, 200) ~ bgp_ext_community then
			{ if client_rtt <= 200 then
			return false; }

		# 500 ms
		if (64530, 500) ~ bgp_community then
			{ if client_rtt <= 500 then
			return false; }
		if (999, 64530, 500) ~ bgp_large_community then
			{ if client_rtt <= 500 then
			return false; }
		if (rt, 64530, 500) ~ bgp_ext_community then
			{ if client_rtt <= 500 then
			return false; }


		# announce_to_peers_with_rtt_higher_than

		# 5 ms
		if (64533, 5) ~ bgp_community then
			{ if client_rtt > 5 then
			return true; }
		if (999, 64533, 5) ~ bgp_large_community then
			{ if client_rtt > 5 then
			return true; }
		if (rt, 64533, 5) ~ bgp_ext_community then
			{ if client_rtt > 5 then
			return true; }

		# 10 ms
		if (64533, 10) ~ bgp_community then
			{ if client_rtt > 10 then
			return true; }
		if (999, 64533, 10) ~ bgp_large_community then
			{ if client_rtt > 10 then
			return true; }
		if (rt, 64533, 10) ~ bgp_ext_community then
			{ if client_rtt > 10 then
			return true; }

		# 15 ms
		if (64533, 15) ~ bgp_community then
			{ if client_rtt > 15 then
			return true; }
		if (999, 64533, 15) ~ bgp_large_community then
			{ if client_rtt > 15 then
			return true; }
		if (rt, 64533, 15) ~ bgp_ext_community then
			{ if client_rtt > 15 then
			return true; }

		# 20 ms
		if (64533, 20) ~ bgp_community then
			{ if client_rtt > 20 then
			return true; }
		if (999, 64533, 20) ~ bgp_large_community then
			{ if client_rtt > 20 then
			return true; }
		if (rt, 64533, 20) ~ bgp_ext_community then
			{ if client_rtt > 20 then
			return true; }

		# 30 ms
		if (64533, 30) ~ bgp_community then
			{ if client_rtt > 30 then
			return true; }
		if (999, 64533, 30) ~ bgp_large_community then
			{ if client_rtt > 30 then
			return true; }
		if (rt, 64533, 30) ~ bgp_ext_community then
			{ if client_rtt > 30 then
			return true; }

		# 50 ms
		if (64533, 50) ~ bgp_community then
			{ if client_rtt > 50 then
			return true; }
		if (999, 64533, 50) ~ bgp_large_community then
			{ if client_rtt > 50 then
			return true; }
		if (rt, 64533, 50) ~ bgp_ext_community then
			{ if client_rtt > 50 then
			return true; }

		# 100 ms
		if (64533, 100) ~ bgp_community then
			{ if client_rtt > 100 then
			return true; }
		if (999, 64533, 100) ~ bgp_large_community then
			{ if client_rtt > 100 then
			return true; }
		if (rt, 64533, 100) ~ bgp_ext_community then
			{ if client_rtt > 100 then
			return true; }

		# 200 ms
		if (64533, 200) ~ bgp_community then
			{ if client_rtt > 200 then
			return true; }
		if (999, 64533, 200) ~ bgp_large_community then
			{ if client_rtt > 200 then
			return true; }
		if (rt, 64533, 200) ~ bgp_ext_community then
			{ if client_rtt > 200 then
			return true; }

		# 500 ms
		if (64533, 500) ~ bgp_community then
			{ if client_rtt > 500 then
			return true; }
		if (999, 64533, 500) ~ bgp_large_community then
			{ if client_rtt > 500 then
			return true; }
		if (rt, 64533, 500) ~ bgp_ext_community then
			{ if client_rtt > 500 then
			return true; }


		# announce_to_peers_with_rtt_lower_than

		# 5 ms
		if (64532, 5) ~ bgp_community then
			{ if client_rtt <= 5 then
			return true; }
		if (999, 64532, 5) ~ bgp_large_community then
			{ if client_rtt <= 5 then
			return true; }
		if (rt, 64532, 5) ~ bgp_ext_community then
			{ if client_rtt <= 5 then
			return true; }

		# 10 ms
		if (64532, 10) ~ bgp_community then
			{ if client_rtt <= 10 then
			return true; }
		if (999, 64532, 10) ~ bgp_large_community then
			{ if client_rtt <= 10 then
			return true; }
		if (rt, 64532, 10) ~ bgp_ext_community then
			{ if client_rtt <= 10 then
			return true; }

		# 15 ms
		if (64532, 15) ~ bgp_community then
			{ if client_rtt <= 15 then
			return true; }
		if (999, 64532, 15) ~ bgp_large_community then
			{ if client_rtt <= 15 then
			return true; }
		if (rt, 64532, 15) ~ bgp_ext_community then
			{ if client_rtt <= 15 then
			return true; }

		# 20 ms
		if (64532, 20) ~ bgp_community then
			{ if client_rtt <= 20 then
			return true; }
		if (999, 64532, 20) ~ bgp_large_community then
			{ if client_rtt <= 20 then
			return true; }
		if (rt, 64532, 20) ~ bgp_ext_community then
			{ if client_rtt <= 20 then
			return true; }

		# 30 ms
		if (64532, 30) ~ bgp_community then
			{ if client_rtt <= 30 then
			return true; }
		if (999, 64532, 30) ~ bgp_large_community then
			{ if client_rtt <= 30 then
			return true; }
		if (rt, 64532, 30) ~ bgp_ext_community then
			{ if client_rtt <= 30 then
			return true; }

		# 50 ms
		if (64532, 50) ~ bgp_community then
			{ if client_rtt <= 50 then
			return true; }
		if (999, 64532, 50) ~ bgp_large_community then
			{ if client_rtt <= 50 then
			return true; }
		if (rt, 64532, 50) ~ bgp_ext_community then
			{ if client_rtt <= 50 then
			return true; }

		# 100 ms
		if (64532, 100) ~ bgp_community then
			{ if client_rtt <= 100 then
			return true; }
		if (999, 64532, 100) ~ bgp_large_community then
			{ if client_rtt <= 100 then
			return true; }
		if (rt, 64532, 100) ~ bgp_ext_community then
			{ if client_rtt <= 100 then
			return true; }

		# 200 ms
		if (64532, 200) ~ bgp_community then
			{ if client_rtt <= 200 then
			return true; }
		if (999, 64532, 200) ~ bgp_large_community then
			{ if client_rtt <= 200 then
			return true; }
		if (rt, 64532, 200) ~ bgp_ext_community then
			{ if client_rtt <= 200 then
			return true; }

		# 500 ms
		if (64532, 500) ~ bgp_community then
			{ if client_rtt <= 500 then
			return true; }
		if (999, 64532, 500) ~ bgp_large_community then
			{ if client_rtt <= 500 then
			return true; }
		if (rt, 64532, 500) ~ bgp_ext_community then
			{ if client_rtt <= 500 then
			return true; }


	}

	# do_not_announce_to_any
	if (0, 999) ~ bgp_community then
		return false;
	if (999, 0, 999) ~ bgp_large_community then
		return false;
	if (rt, 0, 999) ~ bgp_ext_community then
		return false;

	return true;
}

# This function prepends the left-most ASN <times> times.
function do_prepend(int times) {
	case times {
		1: bgp_path.prepend(bgp_path.first);
		2: bgp_path.prepend(bgp_path.first); bgp_path.prepend(bgp_path.first);
		3: bgp_path.prepend(bgp_path.first); bgp_path.prepend(bgp_path.first); bgp_path.prepend(bgp_path.first);
	}
}

# This function verifies if the current route matches one of the
# control communities in charge of prepending client's ASN.
function apply_prepend(int peer_as; ip client_ip) -> bool
int client_rtt;
int mapped_16bit_asn;
{
	# prepend_once_to_peer
	if peer_as <= 65535 then {
		if (65521, peer_as) ~ bgp_community then
			{ do_prepend(1); return true; }
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (65521, mapped_16bit_asn) ~ bgp_community then
				{ do_prepend(1); return true; }
		}
	}
	if (999, 65521, peer_as) ~ bgp_large_community then
		{ do_prepend(1); return true; }
	if (rt, 65521, peer_as) ~ bgp_ext_community then
		{ do_prepend(1); return true; }

	# prepend_twice_to_peer
	if peer_as <= 65535 then {
		if (65522, peer_as) ~ bgp_community then
			{ do_prepend(2); return true; }
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (65522, mapped_16bit_asn) ~ bgp_community then
				{ do_prepend(2); return true; }
		}
	}
	if (999, 65522, peer_as) ~ bgp_large_community then
		{ do_prepend(2); return true; }
	if (rt, 65522, peer_as) ~ bgp_ext_community then
		{ do_prepend(2); return true; }

	# prepend_thrice_to_peer
	if peer_as <= 65535 then {
		if (65523, peer_as) ~ bgp_community then
			{ do_prepend(3); return true; }
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (65523, mapped_16bit_asn) ~ bgp_community then
				{ do_prepend(3); return true; }
		}
	}
	if (999, 65523, peer_as) ~ bgp_large_community then
		{ do_prepend(3); return true; }
	if (rt, 65523, peer_as) ~ bgp_ext_community then
		{ do_prepend(3); return true; }


	client_rtt = get_peer_rtt(client_ip);

	if client_rtt > 0 then {
		# prepend_once_to_peers_with_rtt_higher_than 500 ms
		if (64537, 500) ~ bgp_community then
			{ if client_rtt > 500 then
			{ do_prepend(1); return true; } }
		if (999, 64537, 500) ~ bgp_large_community then
			{ if client_rtt > 500 then
			{ do_prepend(1); return true; } }
		if (rt, 64537, 500) ~ bgp_ext_community then
			{ if client_rtt > 500 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_higher_than 500 ms
		if (64538, 500) ~ bgp_community then
			{ if client_rtt > 500 then
			{ do_prepend(2); return true; } }
		if (999, 64538, 500) ~ bgp_large_community then
			{ if client_rtt > 500 then
			{ do_prepend(2); return true; } }
		if (rt, 64538, 500) ~ bgp_ext_community then
			{ if client_rtt > 500 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_higher_than 500 ms
		if (64539, 500) ~ bgp_community then
			{ if client_rtt > 500 then
			{ do_prepend(3); return true; } }
		if (999, 64539, 500) ~ bgp_large_community then
			{ if client_rtt > 500 then
			{ do_prepend(3); return true; } }
		if (rt, 64539, 500) ~ bgp_ext_community then
			{ if client_rtt > 500 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_higher_than 200 ms
		if (64537, 200) ~ bgp_community then
			{ if client_rtt > 200 then
			{ do_prepend(1); return true; } }
		if (999, 64537, 200) ~ bgp_large_community then
			{ if client_rtt > 200 then
			{ do_prepend(1); return true; } }
		if (rt, 64537, 200) ~ bgp_ext_community then
			{ if client_rtt > 200 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_higher_than 200 ms
		if (64538, 200) ~ bgp_community then
			{ if client_rtt > 200 then
			{ do_prepend(2); return true; } }
		if (999, 64538, 200) ~ bgp_large_community then
			{ if client_rtt > 200 then
			{ do_prepend(2); return true; } }
		if (rt, 64538, 200) ~ bgp_ext_community then
			{ if client_rtt > 200 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_higher_than 200 ms
		if (64539, 200) ~ bgp_community then
			{ if client_rtt > 200 then
			{ do_prepend(3); return true; } }
		if (999, 64539, 200) ~ bgp_large_community then
			{ if client_rtt > 200 then
			{ do_prepend(3); return true; } }
		if (rt, 64539, 200) ~ bgp_ext_community then
			{ if client_rtt > 200 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_higher_than 100 ms
		if (64537, 100) ~ bgp_community then
			{ if client_rtt > 100 then
			{ do_prepend(1); return true; } }
		if (999, 64537, 100) ~ bgp_large_community then
			{ if client_rtt > 100 then
			{ do_prepend(1); return true; } }
		if (rt, 64537, 100) ~ bgp_ext_community then
			{ if client_rtt > 100 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_higher_than 100 ms
		if (64538, 100) ~ bgp_community then
			{ if client_rtt > 100 then
			{ do_prepend(2); return true; } }
		if (999, 64538, 100) ~ bgp_large_community then
			{ if client_rtt > 100 then
			{ do_prepend(2); return true; } }
		if (rt, 64538, 100) ~ bgp_ext_community then
			{ if client_rtt > 100 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_higher_than 100 ms
		if (64539, 100) ~ bgp_community then
			{ if client_rtt > 100 then
			{ do_prepend(3); return true; } }
		if (999, 64539, 100) ~ bgp_large_community then
			{ if client_rtt > 100 then
			{ do_prepend(3); return true; } }
		if (rt, 64539, 100) ~ bgp_ext_community then
			{ if client_rtt > 100 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_higher_than 50 ms
		if (64537, 50) ~ bgp_community then
			{ if client_rtt > 50 then
			{ do_prepend(1); return true; } }
		if (999, 64537, 50) ~ bgp_large_community then
			{ if client_rtt > 50 then
			{ do_prepend(1); return true; } }
		if (rt, 64537, 50) ~ bgp_ext_community then
			{ if client_rtt > 50 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_higher_than 50 ms
		if (64538, 50) ~ bgp_community then
			{ if client_rtt > 50 then
			{ do_prepend(2); return true; } }
		if (999, 64538, 50) ~ bgp_large_community then
			{ if client_rtt > 50 then
			{ do_prepend(2); return true; } }
		if (rt, 64538, 50) ~ bgp_ext_community then
			{ if client_rtt > 50 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_higher_than 50 ms
		if (64539, 50) ~ bgp_community then
			{ if client_rtt > 50 then
			{ do_prepend(3); return true; } }
		if (999, 64539, 50) ~ bgp_large_community then
			{ if client_rtt > 50 then
			{ do_prepend(3); return true; } }
		if (rt, 64539, 50) ~ bgp_ext_community then
			{ if client_rtt > 50 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_higher_than 30 ms
		if (64537, 30) ~ bgp_community then
			{ if client_rtt > 30 then
			{ do_prepend(1); return true; } }
		if (999, 64537, 30) ~ bgp_large_community then
			{ if client_rtt > 30 then
			{ do_prepend(1); return true; } }
		if (rt, 64537, 30) ~ bgp_ext_community then
			{ if client_rtt > 30 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_higher_than 30 ms
		if (64538, 30) ~ bgp_community then
			{ if client_rtt > 30 then
			{ do_prepend(2); return true; } }
		if (999, 64538, 30) ~ bgp_large_community then
			{ if client_rtt > 30 then
			{ do_prepend(2); return true; } }
		if (rt, 64538, 30) ~ bgp_ext_community then
			{ if client_rtt > 30 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_higher_than 30 ms
		if (64539, 30) ~ bgp_community then
			{ if client_rtt > 30 then
			{ do_prepend(3); return true; } }
		if (999, 64539, 30) ~ bgp_large_community then
			{ if client_rtt > 30 then
			{ do_prepend(3); return true; } }
		if (rt, 64539, 30) ~ bgp_ext_community then
			{ if client_rtt > 30 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_higher_than 20 ms
		if (64537, 20) ~ bgp_community then
			{ if client_rtt > 20 then
			{ do_prepend(1); return true; } }
		if (999, 64537, 20) ~ bgp_large_community then
			{ if client_rtt > 20 then
			{ do_prepend(1); return true; } }
		if (rt, 64537, 20) ~ bgp_ext_community then
			{ if client_rtt > 20 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_higher_than 20 ms
		if (64538, 20) ~ bgp_community then
			{ if client_rtt > 20 then
			{ do_prepend(2); return true; } }
		if (999, 64538, 20) ~ bgp_large_community then
			{ if client_rtt > 20 then
			{ do_prepend(2); return true; } }
		if (rt, 64538, 20) ~ bgp_ext_community then
			{ if client_rtt > 20 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_higher_than 20 ms
		if (64539, 20) ~ bgp_community then
			{ if client_rtt > 20 then
			{ do_prepend(3); return true; } }
		if (999, 64539, 20) ~ bgp_large_community then
			{ if client_rtt > 20 then
			{ do_prepend(3); return true; } }
		if (rt, 64539, 20) ~ bgp_ext_community then
			{ if client_rtt > 20 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_higher_than 15 ms
		if (64537, 15) ~ bgp_community then
			{ if client_rtt > 15 then
			{ do_prepend(1); return true; } }
		if (999, 64537, 15) ~ bgp_large_community then
			{ if client_rtt > 15 then
			{ do_prepend(1); return true; } }
		if (rt, 64537, 15) ~ bgp_ext_community then
			{ if client_rtt > 15 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_higher_than 15 ms
		if (64538, 15) ~ bgp_community then
			{ if client_rtt > 15 then
			{ do_prepend(2); return true; } }
		if (999, 64538, 15) ~ bgp_large_community then
			{ if client_rtt > 15 then
			{ do_prepend(2); return true; } }
		if (rt, 64538, 15) ~ bgp_ext_community then
			{ if client_rtt > 15 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_higher_than 15 ms
		if (64539, 15) ~ bgp_community then
			{ if client_rtt > 15 then
			{ do_prepend(3); return true; } }
		if (999, 64539, 15) ~ bgp_large_community then
			{ if client_rtt > 15 then
			{ do_prepend(3); return true; } }
		if (rt, 64539, 15) ~ bgp_ext_community then
			{ if client_rtt > 15 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_higher_than 10 ms
		if (64537, 10) ~ bgp_community then
			{ if client_rtt > 10 then
			{ do_prepend(1); return true; } }
		if (999, 64537, 10) ~ bgp_large_community then
			{ if client_rtt > 10 then
			{ do_prepend(1); return true; } }
		if (rt, 64537, 10) ~ bgp_ext_community then
			{ if client_rtt > 10 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_higher_than 10 ms
		if (64538, 10) ~ bgp_community then
			{ if client_rtt > 10 then
			{ do_prepend(2); return true; } }
		if (999, 64538, 10) ~ bgp_large_community then
			{ if client_rtt > 10 then
			{ do_prepend(2); return true; } }
		if (rt, 64538, 10) ~ bgp_ext_community then
			{ if client_rtt > 10 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_higher_than 10 ms
		if (64539, 10) ~ bgp_community then
			{ if client_rtt > 10 then
			{ do_prepend(3); return true; } }
		if (999, 64539, 10) ~ bgp_large_community then
			{ if client_rtt > 10 then
			{ do_prepend(3); return true; } }
		if (rt, 64539, 10) ~ bgp_ext_community then
			{ if client_rtt > 10 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_higher_than 5 ms
		if (64537, 5) ~ bgp_community then
			{ if client_rtt > 5 then
			{ do_prepend(1); return true; } }
		if (999, 64537, 5) ~ bgp_large_community then
			{ if client_rtt > 5 then
			{ do_prepend(1); return true; } }
		if (rt, 64537, 5) ~ bgp_ext_community then
			{ if client_rtt > 5 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_higher_than 5 ms
		if (64538, 5) ~ bgp_community then
			{ if client_rtt > 5 then
			{ do_prepend(2); return true; } }
		if (999, 64538, 5) ~ bgp_large_community then
			{ if client_rtt > 5 then
			{ do_prepend(2); return true; } }
		if (rt, 64538, 5) ~ bgp_ext_community then
			{ if client_rtt > 5 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_higher_than 5 ms
		if (64539, 5) ~ bgp_community then
			{ if client_rtt > 5 then
			{ do_prepend(3); return true; } }
		if (999, 64539, 5) ~ bgp_large_community then
			{ if client_rtt > 5 then
			{ do_prepend(3); return true; } }
		if (rt, 64539, 5) ~ bgp_ext_community then
			{ if client_rtt > 5 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_lower_than 5 ms
		if (64534, 5) ~ bgp_community then
			{ if client_rtt <= 5 then
			{ do_prepend(1); return true; } }
		if (999, 64534, 5) ~ bgp_large_community then
			{ if client_rtt <= 5 then
			{ do_prepend(1); return true; } }
		if (rt, 64534, 5) ~ bgp_ext_community then
			{ if client_rtt <= 5 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_lower_than 5 ms
		if (64535, 5) ~ bgp_community then
			{ if client_rtt <= 5 then
			{ do_prepend(2); return true; } }
		if (999, 64535, 5) ~ bgp_large_community then
			{ if client_rtt <= 5 then
			{ do_prepend(2); return true; } }
		if (rt, 64535, 5) ~ bgp_ext_community then
			{ if client_rtt <= 5 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_lower_than 5 ms
		if (64536, 5) ~ bgp_community then
			{ if client_rtt <= 5 then
			{ do_prepend(3); return true; } }
		if (999, 64536, 5) ~ bgp_large_community then
			{ if client_rtt <= 5 then
			{ do_prepend(3); return true; } }
		if (rt, 64536, 5) ~ bgp_ext_community then
			{ if client_rtt <= 5 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_lower_than 10 ms
		if (64534, 10) ~ bgp_community then
			{ if client_rtt <= 10 then
			{ do_prepend(1); return true; } }
		if (999, 64534, 10) ~ bgp_large_community then
			{ if client_rtt <= 10 then
			{ do_prepend(1); return true; } }
		if (rt, 64534, 10) ~ bgp_ext_community then
			{ if client_rtt <= 10 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_lower_than 10 ms
		if (64535, 10) ~ bgp_community then
			{ if client_rtt <= 10 then
			{ do_prepend(2); return true; } }
		if (999, 64535, 10) ~ bgp_large_community then
			{ if client_rtt <= 10 then
			{ do_prepend(2); return true; } }
		if (rt, 64535, 10) ~ bgp_ext_community then
			{ if client_rtt <= 10 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_lower_than 10 ms
		if (64536, 10) ~ bgp_community then
			{ if client_rtt <= 10 then
			{ do_prepend(3); return true; } }
		if (999, 64536, 10) ~ bgp_large_community then
			{ if client_rtt <= 10 then
			{ do_prepend(3); return true; } }
		if (rt, 64536, 10) ~ bgp_ext_community then
			{ if client_rtt <= 10 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_lower_than 15 ms
		if (64534, 15) ~ bgp_community then
			{ if client_rtt <= 15 then
			{ do_prepend(1); return true; } }
		if (999, 64534, 15) ~ bgp_large_community then
			{ if client_rtt <= 15 then
			{ do_prepend(1); return true; } }
		if (rt, 64534, 15) ~ bgp_ext_community then
			{ if client_rtt <= 15 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_lower_than 15 ms
		if (64535, 15) ~ bgp_community then
			{ if client_rtt <= 15 then
			{ do_prepend(2); return true; } }
		if (999, 64535, 15) ~ bgp_large_community then
			{ if client_rtt <= 15 then
			{ do_prepend(2); return true; } }
		if (rt, 64535, 15) ~ bgp_ext_community then
			{ if client_rtt <= 15 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_lower_than 15 ms
		if (64536, 15) ~ bgp_community then
			{ if client_rtt <= 15 then
			{ do_prepend(3); return true; } }
		if (999, 64536, 15) ~ bgp_large_community then
			{ if client_rtt <= 15 then
			{ do_prepend(3); return true; } }
		if (rt, 64536, 15) ~ bgp_ext_community then
			{ if client_rtt <= 15 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_lower_than 20 ms
		if (64534, 20) ~ bgp_community then
			{ if client_rtt <= 20 then
			{ do_prepend(1); return true; } }
		if (999, 64534, 20) ~ bgp_large_community then
			{ if client_rtt <= 20 then
			{ do_prepend(1); return true; } }
		if (rt, 64534, 20) ~ bgp_ext_community then
			{ if client_rtt <= 20 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_lower_than 20 ms
		if (64535, 20) ~ bgp_community then
			{ if client_rtt <= 20 then
			{ do_prepend(2); return true; } }
		if (999, 64535, 20) ~ bgp_large_community then
			{ if client_rtt <= 20 then
			{ do_prepend(2); return true; } }
		if (rt, 64535, 20) ~ bgp_ext_community then
			{ if client_rtt <= 20 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_lower_than 20 ms
		if (64536, 20) ~ bgp_community then
			{ if client_rtt <= 20 then
			{ do_prepend(3); return true; } }
		if (999, 64536, 20) ~ bgp_large_community then
			{ if client_rtt <= 20 then
			{ do_prepend(3); return true; } }
		if (rt, 64536, 20) ~ bgp_ext_community then
			{ if client_rtt <= 20 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_lower_than 30 ms
		if (64534, 30) ~ bgp_community then
			{ if client_rtt <= 30 then
			{ do_prepend(1); return true; } }
		if (999, 64534, 30) ~ bgp_large_community then
			{ if client_rtt <= 30 then
			{ do_prepend(1); return true; } }
		if (rt, 64534, 30) ~ bgp_ext_community then
			{ if client_rtt <= 30 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_lower_than 30 ms
		if (64535, 30) ~ bgp_community then
			{ if client_rtt <= 30 then
			{ do_prepend(2); return true; } }
		if (999, 64535, 30) ~ bgp_large_community then
			{ if client_rtt <= 30 then
			{ do_prepend(2); return true; } }
		if (rt, 64535, 30) ~ bgp_ext_community then
			{ if client_rtt <= 30 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_lower_than 30 ms
		if (64536, 30) ~ bgp_community then
			{ if client_rtt <= 30 then
			{ do_prepend(3); return true; } }
		if (999, 64536, 30) ~ bgp_large_community then
			{ if client_rtt <= 30 then
			{ do_prepend(3); return true; } }
		if (rt, 64536, 30) ~ bgp_ext_community then
			{ if client_rtt <= 30 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_lower_than 50 ms
		if (64534, 50) ~ bgp_community then
			{ if client_rtt <= 50 then
			{ do_prepend(1); return true; } }
		if (999, 64534, 50) ~ bgp_large_community then
			{ if client_rtt <= 50 then
			{ do_prepend(1); return true; } }
		if (rt, 64534, 50) ~ bgp_ext_community then
			{ if client_rtt <= 50 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_lower_than 50 ms
		if (64535, 50) ~ bgp_community then
			{ if client_rtt <= 50 then
			{ do_prepend(2); return true; } }
		if (999, 64535, 50) ~ bgp_large_community then
			{ if client_rtt <= 50 then
			{ do_prepend(2); return true; } }
		if (rt, 64535, 50) ~ bgp_ext_community then
			{ if client_rtt <= 50 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_lower_than 50 ms
		if (64536, 50) ~ bgp_community then
			{ if client_rtt <= 50 then
			{ do_prepend(3); return true; } }
		if (999, 64536, 50) ~ bgp_large_community then
			{ if client_rtt <= 50 then
			{ do_prepend(3); return true; } }
		if (rt, 64536, 50) ~ bgp_ext_community then
			{ if client_rtt <= 50 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_lower_than 100 ms
		if (64534, 100) ~ bgp_community then
			{ if client_rtt <= 100 then
			{ do_prepend(1); return true; } }
		if (999, 64534, 100) ~ bgp_large_community then
			{ if client_rtt <= 100 then
			{ do_prepend(1); return true; } }
		if (rt, 64534, 100) ~ bgp_ext_community then
			{ if client_rtt <= 100 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_lower_than 100 ms
		if (64535, 100) ~ bgp_community then
			{ if client_rtt <= 100 then
			{ do_prepend(2); return true; } }
		if (999, 64535, 100) ~ bgp_large_community then
			{ if client_rtt <= 100 then
			{ do_prepend(2); return true; } }
		if (rt, 64535, 100) ~ bgp_ext_community then
			{ if client_rtt <= 100 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_lower_than 100 ms
		if (64536, 100) ~ bgp_community then
			{ if client_rtt <= 100 then
			{ do_prepend(3); return true; } }
		if (999, 64536, 100) ~ bgp_large_community then
			{ if client_rtt <= 100 then
			{ do_prepend(3); return true; } }
		if (rt, 64536, 100) ~ bgp_ext_community then
			{ if client_rtt <= 100 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_lower_than 200 ms
		if (64534, 200) ~ bgp_community then
			{ if client_rtt <= 200 then
			{ do_prepend(1); return true; } }
		if (999, 64534, 200) ~ bgp_large_community then
			{ if client_rtt <= 200 then
			{ do_prepend(1); return true; } }
		if (rt, 64534, 200) ~ bgp_ext_community then
			{ if client_rtt <= 200 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_lower_than 200 ms
		if (64535, 200) ~ bgp_community then
			{ if client_rtt <= 200 then
			{ do_prepend(2); return true; } }
		if (999, 64535, 200) ~ bgp_large_community then
			{ if client_rtt <= 200 then
			{ do_prepend(2); return true; } }
		if (rt, 64535, 200) ~ bgp_ext_community then
			{ if client_rtt <= 200 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_lower_than 200 ms
		if (64536, 200) ~ bgp_community then
			{ if client_rtt <= 200 then
			{ do_prepend(3); return true; } }
		if (999, 64536, 200) ~ bgp_large_community then
			{ if client_rtt <= 200 then
			{ do_prepend(3); return true; } }
		if (rt, 64536, 200) ~ bgp_ext_community then
			{ if client_rtt <= 200 then
			{ do_prepend(3); return true; } }

		# prepend_once_to_peers_with_rtt_lower_than 500 ms
		if (64534, 500) ~ bgp_community then
			{ if client_rtt <= 500 then
			{ do_prepend(1); return true; } }
		if (999, 64534, 500) ~ bgp_large_community then
			{ if client_rtt <= 500 then
			{ do_prepend(1); return true; } }
		if (rt, 64534, 500) ~ bgp_ext_community then
			{ if client_rtt <= 500 then
			{ do_prepend(1); return true; } }

		# prepend_twice_to_peers_with_rtt_lower_than 500 ms
		if (64535, 500) ~ bgp_community then
			{ if client_rtt <= 500 then
			{ do_prepend(2); return true; } }
		if (999, 64535, 500) ~ bgp_large_community then
			{ if client_rtt <= 500 then
			{ do_prepend(2); return true; } }
		if (rt, 64535, 500) ~ bgp_ext_community then
			{ if client_rtt <= 500 then
			{ do_prepend(2); return true; } }

		# prepend_thrice_to_peers_with_rtt_lower_than 500 ms
		if (64536, 500) ~ bgp_community then
			{ if client_rtt <= 500 then
			{ do_prepend(3); return true; } }
		if (999, 64536, 500) ~ bgp_large_community then
			{ if client_rtt <= 500 then
			{ do_prepend(3); return true; } }
		if (rt, 64536, 500) ~ bgp_ext_community then
			{ if client_rtt <= 500 then
			{ do_prepend(3); return true; } }

	}

	# prepend_once_to_any
	if (65521, 65521) ~ bgp_community then
		{ do_prepend(1); return true; }
	if (999, 65521, 65521) ~ bgp_large_community then
		{ do_prepend(1); return true; }
	if (rt, 65521, 65521) ~ bgp_ext_community then
		{ do_prepend(1); return true; }

	# prepend_twice_to_any
	if (65522, 65522) ~ bgp_community then
		{ do_prepend(2); return true; }
	if (999, 65522, 65522) ~ bgp_large_community then
		{ do_prepend(2); return true; }
	if (rt, 65522, 65522) ~ bgp_ext_community then
		{ do_prepend(2); return true; }

	# prepend_thrice_to_any
	if (65523, 65523) ~ bgp_community then
		{ do_prepend(3); return true; }
	if (999, 65523, 65523) ~ bgp_large_community then
		{ do_prepend(3); return true; }
	if (rt, 65523, 65523) ~ bgp_ext_community then
		{ do_prepend(3); return true; }


	return true;
}

# This function adds the BGP communities used to
# keep track of RPKI validation state.
# RFC8097 extended communities are used here.
function add_rpki_community(string comm_name) {
	# RFC8097 BGP communities
	if comm_name = "valid" then {
		bgp_ext_community.add((unknown 0x4300, 0, 0));
	}
	if comm_name = "unknown" then {
		bgp_ext_community.add((unknown 0x4300, 0, 1));
	}
	if comm_name = "invalid" then {
		bgp_ext_community.add((unknown 0x4300, 0, 2));
	}

}

# This functions performs RPKI validation of the current
# route and adds the informative communities.
function perform_rpki_validation () {
	if net.type = NET_IP4 then {
		case roa_check(RPKI4) {
			ROA_VALID: add_rpki_community("valid");
			ROA_UNKNOWN: add_rpki_community("unknown");
			ROA_INVALID: add_rpki_community("invalid");
		}
	} else {
		case roa_check(RPKI6) {
			ROA_VALID: add_rpki_community("valid");
			ROA_UNKNOWN: add_rpki_community("unknown");
			ROA_INVALID: add_rpki_community("invalid");
		}
	}
}

# This function returns True if the route is INVALID.
function route_is_rpki_invalid () -> bool {
	return (unknown 0x4300, 0, 2) ~ bgp_ext_community;
}

# This function returns True if RPKI INVALID routes
# should be announced to clients.
function announce_rpki_invalid_to_client(int client_asn; ip client_ip; string client_id) -> bool {
	return false;
}

# This function adds NO_EXPORT and/or NO_ADVERTISE
# well-known communities.
function add_noexport_noadvertise(int peer_as)
int mapped_16bit_asn;
{
	# add_noexport_to_any
	
	if (65507, 999) ~ bgp_community then
		{ bgp_community.add((65535, 65281)); }
	if (999, 65507, 999) ~ bgp_large_community then
		{ bgp_community.add((65535, 65281)); }
	if (rt, 65507, 999) ~ bgp_ext_community then
		{ bgp_community.add((65535, 65281)); }

	# add_noadvertise_to_any
	
	if (65508, 999) ~ bgp_community then
		{ bgp_community.add((65535, 65282)); }
	if (999, 65508, 999) ~ bgp_large_community then
		{ bgp_community.add((65535, 65282)); }
	if (rt, 65508, 999) ~ bgp_ext_community then
		{ bgp_community.add((65535, 65282)); }

	# add_noexport_to_peer
	
	if peer_as <= 65535 then {
		if (65509, peer_as) ~ bgp_community then
			{ bgp_community.add((65535, 65281)); }
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (65509, mapped_16bit_asn) ~ bgp_community then
				{ bgp_community.add((65535, 65281)); }
		}
	}
	if (999, 65509, peer_as) ~ bgp_large_community then
		{ bgp_community.add((65535, 65281)); }
	if (rt, 65509, peer_as) ~ bgp_ext_community then
		{ bgp_community.add((65535, 65281)); }

	# add_noadvertise_to_peer
	
	if peer_as <= 65535 then {
		if (65510, peer_as) ~ bgp_community then
			{ bgp_community.add((65535, 65282)); }
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (65510, mapped_16bit_asn) ~ bgp_community then
				{ bgp_community.add((65535, 65282)); }
		}
	}
	if (999, 65510, peer_as) ~ bgp_large_community then
		{ bgp_community.add((65535, 65282)); }
	if (rt, 65510, peer_as) ~ bgp_ext_community then
		{ bgp_community.add((65535, 65282)); }

}

function tag_and_reject(int cause; int announcing_asn)
int dyn_val;
int mapped_16bit_asn;
{
	# 0: the route must be treated as discarded
	dyn_val = 0;
	bgp_community.add((65520, dyn_val));


	# cause: the reject cause
	dyn_val = cause;

	# add the generic community from reject_cause
	bgp_community.add((65520, dyn_val));


	# communities from reject_cause_map
	case cause {
		# 6 = Invalid left-most ASN
		6 : bgp_large_community.add((999, 1101, 7));
	}

	# announcing_asn: the ASN of the peer that announced the route
	dyn_val = announcing_asn;

	if announcing_asn <= 65535 then {
		bgp_community.add((65524, dyn_val));
		bgp_ext_community.add((rt, 65524, dyn_val));

	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(announcing_asn);

		if mapped_16bit_asn > 0 then {
			bgp_community.add((65524, mapped_16bit_asn));
			bgp_ext_community.add((rt, 65524, dyn_val));

		} else {
			# Ignoring the std community for 32bit ASNs not present in the 32-to-16 map.
			bgp_ext_community.add((rt, 65524, dyn_val));

		}
	}

	bgp_local_pref = 1;
}

function honor_graceful_shutdown() {
	if (65535, 0) ~ bgp_community then {
		bgp_local_pref = 5;
	}
}

function prevent_graceful_shutdown() {
	if (65535, 0) ~ bgp_community then {
		bgp_community.delete([(65535, 0)]);
	}
}


# This function verifies if there is such a ROA for the
# current route's origin ASN to validate the announced prefix.
function prefix_in_rpki_roas_as_route_objects() -> bool {
	if net.type = NET_IP4 then {
		case roa_check(RPKI4) {
			ROA_VALID: return true;
		}
	} else {
		case roa_check(RPKI6) {
			ROA_VALID: return true;
		}
	}
	return false;
}




# ---------------------------------------------------------
# MEMBERS


# AS-SET for AS151866_1
function origin_as_is_in_AS151866_1_as_set() -> bool {
	# AS-SET AS151866 referenced but empty.
	return false;
}

# R-SET for AS151866_1
function prefix_is_in_AS151866_1_as_set() -> bool {
	# AS-SET AS151866 referenced but empty.
    return false;
}

function next_hop_is_valid_for_AS151866_1() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS151866_1
	if bgp_next_hop = 192.0.2.51 then return true;
	return false;
}


function verify_AS151866_1_irrdb()
bool origin_ok;
bool prefix_ok;
bool validated;
{
	origin_ok = false;
	prefix_ok = false;
	validated = false;

	origin_ok = origin_as_is_in_AS151866_1_as_set();
	prefix_ok = prefix_is_in_AS151866_1_as_set();


	# Origin ASN is valid, prefix is not: check if a RPKI ROAs exists.
	if origin_ok && prefix_in_rpki_roas_as_route_objects() then {
		validated = true;
	}




	if !validated && !origin_ok then {
		tag_and_reject(9, 151866); print "origin ASN [", bgp_path.last, "] not in allowed as-sets - REJECTING ", net; accept;
	}
	if !validated && !prefix_ok then {
		tag_and_reject(12, 151866); print "prefix not in client's r_set - REJECTING ", net; accept;
	}
}

filter receive_from_AS151866_1 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 151866); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP4) then
		{ tag_and_reject(65535, 151866); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS151866_1() then
		{ tag_and_reject(5, 151866); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 151866); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 151866 then
		{ tag_and_reject(6, 151866); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 151866); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [3, 174] then
		{ tag_and_reject(8, 151866); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 151866); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }


	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 151866); print "prefix is in global blacklist - REJECTING ", net; accept; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 151866); print "prefix is bogon - REJECTING ", net; accept; }

	# IRRdb checks
	verify_AS151866_1_irrdb();

	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS151866_1 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 151866); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(8, 24) then
			{ tag_and_reject(13, 151866); print "prefix len [", net.len, "] not in 8-24 - REJECTING ", net; accept; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS151866_1
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(151866, 192.0.2.51, "AS151866_1") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS151866_1";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(151866, 192.0.2.51, "AS151866_1") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS151866_1";

	apply_prepend(151866, 192.0.2.51);


	add_noexport_noadvertise(151866);

	scrub_communities_out();



	accept;
}

protocol bgp AS151866_1 {
	description "151866 client";

	local as 999;
	neighbor 192.0.2.51 as 151866;
	rs client;


	passive on;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv4 {
	table master4;


	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS151866_1;
	export filter announce_to_AS151866_1;
	# ---------------------------------------
	};

		}


# AS-SET for AS151866_2
function origin_as_is_in_AS151866_2_as_set() -> bool {
	# AS-SET AS151866 referenced but empty.
	return false;
}

# R-SET for AS151866_2
function prefix_is_in_AS151866_2_as_set() -> bool {
	# AS-SET AS151866 referenced but empty.
    return false;
}

function next_hop_is_valid_for_AS151866_2() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS151866_2
	if bgp_next_hop = 2001:db8:1:1::51 then return true;
	return false;
}


function verify_AS151866_2_irrdb()
bool origin_ok;
bool prefix_ok;
bool validated;
{
	origin_ok = false;
	prefix_ok = false;
	validated = false;

	origin_ok = origin_as_is_in_AS151866_2_as_set();
	prefix_ok = prefix_is_in_AS151866_2_as_set();


	# Origin ASN is valid, prefix is not: check if a RPKI ROAs exists.
	if origin_ok && prefix_in_rpki_roas_as_route_objects() then {
		validated = true;
	}




	if !validated && !origin_ok then {
		tag_and_reject(9, 151866); print "origin ASN [", bgp_path.last, "] not in allowed as-sets - REJECTING ", net; accept;
	}
	if !validated && !prefix_ok then {
		tag_and_reject(12, 151866); print "prefix not in client's r_set - REJECTING ", net; accept;
	}
}

filter receive_from_AS151866_2 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 151866); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP6) then
		{ tag_and_reject(65535, 151866); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS151866_2() then
		{ tag_and_reject(5, 151866); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 151866); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 151866 then
		{ tag_and_reject(6, 151866); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 151866); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [3, 174] then
		{ tag_and_reject(8, 151866); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 151866); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }

	# Prefix: only IPv6 Global Unicast space allowed
	if net.type = NET_IP6 && !(net ~ [2000::/3+]) then
		{ tag_and_reject(10, 151866); print "prefix is not in IPv6 Global Unicast space - REJECTING ", net; accept; }

	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 151866); print "prefix is in global blacklist - REJECTING ", net; accept; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 151866); print "prefix is bogon - REJECTING ", net; accept; }

	# IRRdb checks
	verify_AS151866_2_irrdb();

	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS151866_2 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 151866); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(17, 48) then
			{ tag_and_reject(13, 151866); print "prefix len [", net.len, "] not in 17-48 - REJECTING ", net; accept; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS151866_2
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(151866, 2001:db8:1:1::51, "AS151866_2") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS151866_2";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(151866, 2001:db8:1:1::51, "AS151866_2") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS151866_2";

	apply_prepend(151866, 2001:db8:1:1::51);


	add_noexport_noadvertise(151866);

	scrub_communities_out();



	accept;
}

protocol bgp AS151866_2 {
	description "151866 client";

	local as 999;
	neighbor 2001:db8:1:1::51 as 151866;
	rs client;


	passive on;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv6 {
	table master6;


	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS151866_2;
	export filter announce_to_AS151866_2;
	# ---------------------------------------
	};

		}


# AS-SET for AS1_1
function origin_as_is_in_AS1_1_as_set() -> bool {
	if bgp_path.last ~ AS_SET_AS_AS1_AS_AS1_CUSTOMERS_asns then
		return true;
	# AS-SET AS1 referenced but empty.
	if bgp_path.last ~ AS_SET_WHITE_LIST_AS1_1_asns then
		return true;
	return false;
}

# R-SET for AS1_1
function prefix_is_in_AS1_1_as_set() -> bool {
	# AS-SET AS_AS1_AS_AS1_CUSTOMERS referenced but empty.
	# AS-SET AS1 referenced but empty.
    if net.type = NET_IP4 then
        if net ~ AS_SET_WHITE_LIST_AS1_1_prefixes_4 then
            return true;
    return false;
}

function next_hop_is_valid_for_AS1_1() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS1_1
	if bgp_next_hop = 192.0.2.11 then return true;
	return false;
}


function verify_AS1_1_irrdb()
bool origin_ok;
bool prefix_ok;
bool validated;
{
	origin_ok = false;
	prefix_ok = false;
	validated = false;

	origin_ok = origin_as_is_in_AS1_1_as_set();
	prefix_ok = prefix_is_in_AS1_1_as_set();


	# Origin ASN is valid, prefix is not: check if a RPKI ROAs exists.
	if origin_ok && prefix_in_rpki_roas_as_route_objects() then {
		validated = true;
	}



	# Client's white list
	if !validated && net ~ [ 11.3.0.0/16 ] then {
		if bgp_path.last = 1011 then {
			validated = true;
		}
	}
	if !validated && net ~ [ 11.4.0.0/16{16,32} ] then {
		validated = true;
	}

	if !validated && !origin_ok then {
		tag_and_reject(9, 1); print "origin ASN [", bgp_path.last, "] not in allowed as-sets - REJECTING ", net; accept;
	}
	if !validated && !prefix_ok then {
		tag_and_reject(12, 1); print "prefix not in client's r_set - REJECTING ", net; accept;
	}
}

filter receive_from_AS1_1 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 1); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP4) then
		{ tag_and_reject(65535, 1); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS1_1() then
		{ tag_and_reject(5, 1); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 1); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 1 then
		{ tag_and_reject(6, 1); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 1); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [3, 174] then
		{ tag_and_reject(8, 1); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 1); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }


	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 1); print "prefix is in global blacklist - REJECTING ", net; accept; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 1); print "prefix is bogon - REJECTING ", net; accept; }

	# IRRdb checks
	verify_AS1_1_irrdb();

	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS1_1 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 1); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(8, 24) then
			{ tag_and_reject(13, 1); print "prefix len [", net.len, "] not in 8-24 - REJECTING ", net; accept; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS1_1
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(1, 192.0.2.11, "AS1_1") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS1_1";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(1, 192.0.2.11, "AS1_1") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS1_1";

	apply_prepend(1, 192.0.2.11);


	add_noexport_noadvertise(1);

	scrub_communities_out();



	accept;
}

protocol bgp AS1_1 {
	description "AS1_1 client";

	local as 999;
	neighbor 192.0.2.11 as 1;
	rs client;


	passive on;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv4 {
	table master4;


	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS1_1;
	export filter announce_to_AS1_1;
	# ---------------------------------------
	};

		}


# AS-SET for AS1_2
function origin_as_is_in_AS1_2_as_set() -> bool {
	if bgp_path.last ~ AS_SET_AS_AS1_AS_AS1_CUSTOMERS_asns then
		return true;
	if bgp_path.last ~ AS_SET_WHITE_LIST_AS1_2_asns then
		return true;
	# AS-SET AS1 referenced but empty.
	return false;
}

# R-SET for AS1_2
function prefix_is_in_AS1_2_as_set() -> bool {
    if net.type = NET_IP6 then
        if net ~ AS_SET_AS_AS1_AS_AS1_CUSTOMERS_prefixes_6 then
            return true;
    if net.type = NET_IP6 then
        if net ~ AS_SET_WHITE_LIST_AS1_2_prefixes_6 then
            return true;
	# AS-SET AS1 referenced but empty.
    return false;
}

function next_hop_is_valid_for_AS1_2() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS1_2
	if bgp_next_hop = 2001:db8:1:1::11 then return true;
	return false;
}


function verify_AS1_2_irrdb()
bool origin_ok;
bool prefix_ok;
bool validated;
{
	origin_ok = false;
	prefix_ok = false;
	validated = false;

	origin_ok = origin_as_is_in_AS1_2_as_set();
	prefix_ok = prefix_is_in_AS1_2_as_set();


	# Origin ASN is valid, prefix is not: check if a RPKI ROAs exists.
	if origin_ok && prefix_in_rpki_roas_as_route_objects() then {
		validated = true;
	}



	# Client's white list
	if !validated && net ~ [ 2a11:3::/32 ] then {
		if bgp_path.last = 1011 then {
			validated = true;
		}
	}
	if !validated && net ~ [ 2a11:4::/32{32,128} ] then {
		validated = true;
	}

	if !validated && !origin_ok then {
		tag_and_reject(9, 1); print "origin ASN [", bgp_path.last, "] not in allowed as-sets - REJECTING ", net; accept;
	}
	if !validated && !prefix_ok then {
		tag_and_reject(12, 1); print "prefix not in client's r_set - REJECTING ", net; accept;
	}
}

filter receive_from_AS1_2 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 1); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP6) then
		{ tag_and_reject(65535, 1); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS1_2() then
		{ tag_and_reject(5, 1); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 1); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 1 then
		{ tag_and_reject(6, 1); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 1); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [3, 174] then
		{ tag_and_reject(8, 1); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 1); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }

	# Prefix: only IPv6 Global Unicast space allowed
	if net.type = NET_IP6 && !(net ~ [2000::/3+]) then
		{ tag_and_reject(10, 1); print "prefix is not in IPv6 Global Unicast space - REJECTING ", net; accept; }

	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 1); print "prefix is in global blacklist - REJECTING ", net; accept; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 1); print "prefix is bogon - REJECTING ", net; accept; }

	# IRRdb checks
	verify_AS1_2_irrdb();

	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS1_2 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 1); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(17, 48) then
			{ tag_and_reject(13, 1); print "prefix len [", net.len, "] not in 17-48 - REJECTING ", net; accept; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS1_2
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(1, 2001:db8:1:1::11, "AS1_2") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS1_2";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(1, 2001:db8:1:1::11, "AS1_2") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS1_2";

	apply_prepend(1, 2001:db8:1:1::11);


	add_noexport_noadvertise(1);

	scrub_communities_out();



	accept;
}

protocol bgp AS1_2 {
	description "AS1_1 client";

	local as 999;
	neighbor 2001:db8:1:1::11 as 1;
	rs client;


	passive on;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv6 {
	table master6;


	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS1_2;
	export filter announce_to_AS1_2;
	# ---------------------------------------
	};

		}


# AS-SET for AS1_3
function origin_as_is_in_AS1_3_as_set() -> bool {
	if bgp_path.last ~ AS_SET_AS_AS1_AS_AS1_CUSTOMERS_asns then
		return true;
	# AS-SET AS1 referenced but empty.
	return false;
}

# R-SET for AS1_3
function prefix_is_in_AS1_3_as_set() -> bool {
	# AS-SET AS_AS1_AS_AS1_CUSTOMERS referenced but empty.
	# AS-SET AS1 referenced but empty.
    return false;
}

function next_hop_is_valid_for_AS1_3() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS1_3
	if bgp_next_hop = 192.0.2.11 then return true;	# AS1_1
	if bgp_next_hop = 192.0.2.12 then return true;	# AS1_3
	return false;
}


function verify_AS1_3_irrdb()
bool origin_ok;
bool prefix_ok;
bool validated;
{
	origin_ok = false;
	prefix_ok = false;
	validated = false;

	origin_ok = origin_as_is_in_AS1_3_as_set();
	prefix_ok = prefix_is_in_AS1_3_as_set();


	# Origin ASN is valid, prefix is not: check if a RPKI ROAs exists.
	if origin_ok && prefix_in_rpki_roas_as_route_objects() then {
		validated = true;
	}




	if !validated && !origin_ok then {
		tag_and_reject(9, 1); print "origin ASN [", bgp_path.last, "] not in allowed as-sets - REJECTING ", net; accept;
	}
	if !validated && !prefix_ok then {
		tag_and_reject(12, 1); print "prefix not in client's r_set - REJECTING ", net; accept;
	}
}

filter receive_from_AS1_3 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 1); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP4) then
		{ tag_and_reject(65535, 1); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS1_3() then
		{ tag_and_reject(5, 1); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 1); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 1 then
		{ tag_and_reject(6, 1); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 1); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [3, 174] then
		{ tag_and_reject(8, 1); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 1); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }


	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 1); print "prefix is in global blacklist - REJECTING ", net; accept; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 1); print "prefix is bogon - REJECTING ", net; accept; }

	# IRRdb checks
	verify_AS1_3_irrdb();

	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS1_3 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 1); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(8, 24) then
			{ tag_and_reject(13, 1); print "prefix len [", net.len, "] not in 8-24 - REJECTING ", net; accept; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS1_3
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		reject "client AS1_3 not enabled to receive blackhole prefixes - NOT ANNOUNCING ", net, " TO AS1_3";
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(1, 192.0.2.12, "AS1_3") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS1_3";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(1, 192.0.2.12, "AS1_3") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS1_3";

	apply_prepend(1, 192.0.2.12);


	add_noexport_noadvertise(1);

	scrub_communities_out();



	accept;
}

protocol bgp AS1_3 {
	description "AS1_2 client";

	local as 999;
	neighbor 192.0.2.12 as 1;
	rs client;


	passive on;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv4 {
	table master4;


	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS1_3;
	export filter announce_to_AS1_3;
	# ---------------------------------------
	};

		}


# AS-SET for AS1_4
function origin_as_is_in_AS1_4_as_set() -> bool {
	if bgp_path.last ~ AS_SET_AS_AS1_AS_AS1_CUSTOMERS_asns then
		return true;
	# AS-SET AS1 referenced but empty.
	return false;
}

# R-SET for AS1_4
function prefix_is_in_AS1_4_as_set() -> bool {
    if net.type = NET_IP6 then
        if net ~ AS_SET_AS_AS1_AS_AS1_CUSTOMERS_prefixes_6 then
            return true;
	# AS-SET AS1 referenced but empty.
    return false;
}

function next_hop_is_valid_for_AS1_4() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS1_4
	if bgp_next_hop = 2001:db8:1:1::11 then return true;	# AS1_2
	if bgp_next_hop = 2001:db8:1:1::12 then return true;	# AS1_4
	return false;
}


function verify_AS1_4_irrdb()
bool origin_ok;
bool prefix_ok;
bool validated;
{
	origin_ok = false;
	prefix_ok = false;
	validated = false;

	origin_ok = origin_as_is_in_AS1_4_as_set();
	prefix_ok = prefix_is_in_AS1_4_as_set();


	# Origin ASN is valid, prefix is not: check if a RPKI ROAs exists.
	if origin_ok && prefix_in_rpki_roas_as_route_objects() then {
		validated = true;
	}




	if !validated && !origin_ok then {
		tag_and_reject(9, 1); print "origin ASN [", bgp_path.last, "] not in allowed as-sets - REJECTING ", net; accept;
	}
	if !validated && !prefix_ok then {
		tag_and_reject(12, 1); print "prefix not in client's r_set - REJECTING ", net; accept;
	}
}

filter receive_from_AS1_4 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 1); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP6) then
		{ tag_and_reject(65535, 1); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS1_4() then
		{ tag_and_reject(5, 1); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 1); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 1 then
		{ tag_and_reject(6, 1); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 1); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [3, 174] then
		{ tag_and_reject(8, 1); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 1); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }

	# Prefix: only IPv6 Global Unicast space allowed
	if net.type = NET_IP6 && !(net ~ [2000::/3+]) then
		{ tag_and_reject(10, 1); print "prefix is not in IPv6 Global Unicast space - REJECTING ", net; accept; }

	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 1); print "prefix is in global blacklist - REJECTING ", net; accept; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 1); print "prefix is bogon - REJECTING ", net; accept; }

	# IRRdb checks
	verify_AS1_4_irrdb();

	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS1_4 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 1); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(17, 48) then
			{ tag_and_reject(13, 1); print "prefix len [", net.len, "] not in 17-48 - REJECTING ", net; accept; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS1_4
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		reject "client AS1_4 not enabled to receive blackhole prefixes - NOT ANNOUNCING ", net, " TO AS1_4";
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(1, 2001:db8:1:1::12, "AS1_4") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS1_4";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(1, 2001:db8:1:1::12, "AS1_4") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS1_4";

	apply_prepend(1, 2001:db8:1:1::12);


	add_noexport_noadvertise(1);

	scrub_communities_out();



	accept;
}

protocol bgp AS1_4 {
	description "AS1_2 client";

	local as 999;
	neighbor 2001:db8:1:1::12 as 1;
	rs client;


	passive on;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv6 {
	table master6;


	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS1_4;
	export filter announce_to_AS1_4;
	# ---------------------------------------
	};

		}


# AS-SET for AS222_1
function origin_as_is_in_AS222_1_as_set() -> bool {
	# AS-SET AS222 referenced but empty.
	# AS-SET AS_AS222 referenced but empty.
	return false;
}

# R-SET for AS222_1
function prefix_is_in_AS222_1_as_set() -> bool {
	# AS-SET AS222 referenced but empty.
	# AS-SET AS_AS222 referenced but empty.
    return false;
}

function next_hop_is_valid_for_AS222_1() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS222_1
	if bgp_next_hop = 192.0.2.222 then return true;
	return false;
}


function verify_AS222_1_irrdb()
bool origin_ok;
bool prefix_ok;
bool validated;
{
	origin_ok = false;
	prefix_ok = false;
	validated = false;

	origin_ok = origin_as_is_in_AS222_1_as_set();
	prefix_ok = prefix_is_in_AS222_1_as_set();


	# Origin ASN is valid, prefix is not: check if a RPKI ROAs exists.
	if origin_ok && prefix_in_rpki_roas_as_route_objects() then {
		validated = true;
	}



	# Client's white list
	if !validated && net ~ [ 222.1.1.0/24 ] then {
		validated = true;
	}

	if !validated && !origin_ok then {
		tag_and_reject(9, 222); print "origin ASN [", bgp_path.last, "] not in allowed as-sets - REJECTING ", net; accept;
	}
	if !validated && !prefix_ok then {
		tag_and_reject(12, 222); print "prefix not in client's r_set - REJECTING ", net; accept;
	}
}

filter receive_from_AS222_1 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 222); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP4) then
		{ tag_and_reject(65535, 222); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS222_1() then
		{ tag_and_reject(5, 222); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 222); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 222 then
		{ tag_and_reject(6, 222); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 222); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [3, 174] then
		{ tag_and_reject(8, 222); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 222); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }


	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 222); print "prefix is in global blacklist - REJECTING ", net; accept; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 222); print "prefix is bogon - REJECTING ", net; accept; }

	# IRRdb checks
	verify_AS222_1_irrdb();

	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS222_1 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 222); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(8, 24) then
			{ tag_and_reject(13, 222); print "prefix len [", net.len, "] not in 8-24 - REJECTING ", net; accept; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS222_1
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(222, 192.0.2.222, "AS222_1") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS222_1";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(222, 192.0.2.222, "AS222_1") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS222_1";

	apply_prepend(222, 192.0.2.222);


	add_noexport_noadvertise(222);

	scrub_communities_out();



	accept;
}

protocol bgp AS222_1 {
	description "AS222_1 client";

	local as 999;
	neighbor 192.0.2.222 as 222;
	rs client;


	passive off;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv4 {
	table master4;


	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS222_1;
	export filter announce_to_AS222_1;
	# ---------------------------------------
	};

		}


# AS-SET for AS222_2
function origin_as_is_in_AS222_2_as_set() -> bool {
	# AS-SET AS222 referenced but empty.
	# AS-SET AS_AS222 referenced but empty.
	return false;
}

# R-SET for AS222_2
function prefix_is_in_AS222_2_as_set() -> bool {
	# AS-SET AS222 referenced but empty.
	# AS-SET AS_AS222 referenced but empty.
    return false;
}

function next_hop_is_valid_for_AS222_2() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS222_2
	if bgp_next_hop = 2001:db8:1:1::222 then return true;
	return false;
}


function verify_AS222_2_irrdb()
bool origin_ok;
bool prefix_ok;
bool validated;
{
	origin_ok = false;
	prefix_ok = false;
	validated = false;

	origin_ok = origin_as_is_in_AS222_2_as_set();
	prefix_ok = prefix_is_in_AS222_2_as_set();


	# Origin ASN is valid, prefix is not: check if a RPKI ROAs exists.
	if origin_ok && prefix_in_rpki_roas_as_route_objects() then {
		validated = true;
	}



	# Client's white list
	if !validated && net ~ [ 3222:0:1::/48 ] then {
		validated = true;
	}

	if !validated && !origin_ok then {
		tag_and_reject(9, 222); print "origin ASN [", bgp_path.last, "] not in allowed as-sets - REJECTING ", net; accept;
	}
	if !validated && !prefix_ok then {
		tag_and_reject(12, 222); print "prefix not in client's r_set - REJECTING ", net; accept;
	}
}

filter receive_from_AS222_2 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 222); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP6) then
		{ tag_and_reject(65535, 222); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS222_2() then
		{ tag_and_reject(5, 222); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 222); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 222 then
		{ tag_and_reject(6, 222); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 222); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [3, 174] then
		{ tag_and_reject(8, 222); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 222); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }

	# Prefix: only IPv6 Global Unicast space allowed
	if net.type = NET_IP6 && !(net ~ [2000::/3+]) then
		{ tag_and_reject(10, 222); print "prefix is not in IPv6 Global Unicast space - REJECTING ", net; accept; }

	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 222); print "prefix is in global blacklist - REJECTING ", net; accept; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 222); print "prefix is bogon - REJECTING ", net; accept; }

	# IRRdb checks
	verify_AS222_2_irrdb();

	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS222_2 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 222); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(17, 48) then
			{ tag_and_reject(13, 222); print "prefix len [", net.len, "] not in 17-48 - REJECTING ", net; accept; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS222_2
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(222, 2001:db8:1:1::222, "AS222_2") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS222_2";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(222, 2001:db8:1:1::222, "AS222_2") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS222_2";

	apply_prepend(222, 2001:db8:1:1::222);


	add_noexport_noadvertise(222);

	scrub_communities_out();



	accept;
}

protocol bgp AS222_2 {
	description "AS222_1 client";

	local as 999;
	neighbor 2001:db8:1:1::222 as 222;
	rs client;


	passive off;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv6 {
	table master6;


	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS222_2;
	export filter announce_to_AS222_2;
	# ---------------------------------------
	};

		}


# AS-SET for AS2_1
function origin_as_is_in_AS2_1_as_set() -> bool {
	# AS-SET AS2 referenced but empty.
	if bgp_path.last ~ AS_SET_AS_AS2_AS_AS2_CUSTOMERS_asns then
		return true;
	return false;
}

# R-SET for AS2_1
function prefix_is_in_AS2_1_as_set() -> bool {
	# AS-SET AS2 referenced but empty.
	# AS-SET AS_AS2_AS_AS2_CUSTOMERS referenced but empty.
    return false;
}

function next_hop_is_valid_for_AS2_1() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS2_1
	if bgp_next_hop = 192.0.2.21 then return true;
	if bgp_next_hop = 192.0.2.22 then return true;
	return false;
}


function verify_AS2_1_irrdb()
bool origin_ok;
bool prefix_ok;
bool validated;
{
	origin_ok = false;
	prefix_ok = false;
	validated = false;

	origin_ok = origin_as_is_in_AS2_1_as_set();
	prefix_ok = prefix_is_in_AS2_1_as_set();


	# Origin ASN is valid, prefix is not: check if a RPKI ROAs exists.
	if origin_ok && prefix_in_rpki_roas_as_route_objects() then {
		validated = true;
	}




	if !validated && !origin_ok then {
		tag_and_reject(9, 2); print "origin ASN [", bgp_path.last, "] not in allowed as-sets - REJECTING ", net; accept;
	}
	if !validated && !prefix_ok then {
		tag_and_reject(12, 2); print "prefix not in client's r_set - REJECTING ", net; accept;
	}
}

filter receive_from_AS2_1 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 2); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP4) then
		{ tag_and_reject(65535, 2); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS2_1() then
		{ tag_and_reject(5, 2); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 2); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 2 then
		{ tag_and_reject(6, 2); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 2); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [3, 174] then
		{ tag_and_reject(8, 2); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 2); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }


	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 2); print "prefix is in global blacklist - REJECTING ", net; accept; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 2); print "prefix is bogon - REJECTING ", net; accept; }

	# IRRdb checks
	verify_AS2_1_irrdb();

	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS2_1 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 2); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(8, 24) then
			{ tag_and_reject(13, 2); print "prefix len [", net.len, "] not in 8-24 - REJECTING ", net; accept; }

		prevent_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS2_1
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(2, 192.0.2.21, "AS2_1") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS2_1";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(2, 192.0.2.21, "AS2_1") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS2_1";

	apply_prepend(2, 192.0.2.21);


	add_noexport_noadvertise(2);

	scrub_communities_out();



	accept;
}

protocol bgp AS2_1 {
	description "AS2_1 client";

	local as 999;
	neighbor 192.0.2.21 as 2;
	rs client;


	passive on;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv4 {
	table master4;


	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS2_1;
	export filter announce_to_AS2_1;
	# ---------------------------------------
	};

		}


# AS-SET for AS2_2
function origin_as_is_in_AS2_2_as_set() -> bool {
	# AS-SET AS2 referenced but empty.
	if bgp_path.last ~ AS_SET_AS_AS2_AS_AS2_CUSTOMERS_asns then
		return true;
	return false;
}

# R-SET for AS2_2
function prefix_is_in_AS2_2_as_set() -> bool {
	# AS-SET AS2 referenced but empty.
    if net.type = NET_IP6 then
        if net ~ AS_SET_AS_AS2_AS_AS2_CUSTOMERS_prefixes_6 then
            return true;
    return false;
}

function next_hop_is_valid_for_AS2_2() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS2_2
	if bgp_next_hop = 2001:db8:1:1::21 then return true;
	if bgp_next_hop = 2001:db8:1:1::22 then return true;
	return false;
}


function verify_AS2_2_irrdb()
bool origin_ok;
bool prefix_ok;
bool validated;
{
	origin_ok = false;
	prefix_ok = false;
	validated = false;

	origin_ok = origin_as_is_in_AS2_2_as_set();
	prefix_ok = prefix_is_in_AS2_2_as_set();


	# Origin ASN is valid, prefix is not: check if a RPKI ROAs exists.
	if origin_ok && prefix_in_rpki_roas_as_route_objects() then {
		validated = true;
	}




	if !validated && !origin_ok then {
		tag_and_reject(9, 2); print "origin ASN [", bgp_path.last, "] not in allowed as-sets - REJECTING ", net; accept;
	}
	if !validated && !prefix_ok then {
		tag_and_reject(12, 2); print "prefix not in client's r_set - REJECTING ", net; accept;
	}
}

filter receive_from_AS2_2 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 2); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP6) then
		{ tag_and_reject(65535, 2); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS2_2() then
		{ tag_and_reject(5, 2); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 2); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 2 then
		{ tag_and_reject(6, 2); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 2); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [3, 174] then
		{ tag_and_reject(8, 2); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 2); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }

	# Prefix: only IPv6 Global Unicast space allowed
	if net.type = NET_IP6 && !(net ~ [2000::/3+]) then
		{ tag_and_reject(10, 2); print "prefix is not in IPv6 Global Unicast space - REJECTING ", net; accept; }

	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 2); print "prefix is in global blacklist - REJECTING ", net; accept; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 2); print "prefix is bogon - REJECTING ", net; accept; }

	# IRRdb checks
	verify_AS2_2_irrdb();

	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS2_2 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 2); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(17, 48) then
			{ tag_and_reject(13, 2); print "prefix len [", net.len, "] not in 17-48 - REJECTING ", net; accept; }

		prevent_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS2_2
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(2, 2001:db8:1:1::21, "AS2_2") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS2_2";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(2, 2001:db8:1:1::21, "AS2_2") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS2_2";

	apply_prepend(2, 2001:db8:1:1::21);


	add_noexport_noadvertise(2);

	scrub_communities_out();



	accept;
}

protocol bgp AS2_2 {
	description "AS2_1 client";

	local as 999;
	neighbor 2001:db8:1:1::21 as 2;
	rs client;


	passive on;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv6 {
	table master6;


	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS2_2;
	export filter announce_to_AS2_2;
	# ---------------------------------------
	};

		}


# AS-SET for AS3_1
function origin_as_is_in_AS3_1_as_set() -> bool {
	return false;
}

# R-SET for AS3_1
function prefix_is_in_AS3_1_as_set() -> bool {
    return false;
}

function next_hop_is_valid_for_AS3_1() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS3_1
	if bgp_next_hop = 192.0.2.31 then return true;
	return false;
}

function prefix_is_in_AS3_1_blacklist() -> bool
prefix set AS3_1_blacklist_4;
prefix set AS3_1_blacklist_6;
{
    AS3_1_blacklist_4 = [
		# bad network
		3.0.1.0/24{24,32}
    ];
    if net.type = NET_IP4 then
        if net ~ AS3_1_blacklist_4 then return true;
    AS3_1_blacklist_6 = [
		# bad network
		2a03:0:1::/48{48,128}
    ];
    if net.type = NET_IP6 then
        if net ~ AS3_1_blacklist_6 then return true;
	return false;
}


filter receive_from_AS3_1 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 3); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP4) then
		{ tag_and_reject(65535, 3); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS3_1() then
		{ tag_and_reject(5, 3); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 3); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 3 then
		{ tag_and_reject(6, 3); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 3); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [174] then
		{ tag_and_reject(8, 3); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 3); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }


	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 3); print "prefix is in global blacklist - REJECTING ", net; accept; }

	# Prefix: client's blacklist
	if prefix_is_in_AS3_1_blacklist() then
		{ tag_and_reject(11, 3); print "prefix is in client's blacklist - REJECTING ", net; accept; }

	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 3); print "prefix is bogon - REJECTING ", net; accept; }


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS3_1 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 3); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(8, 24) then
			{ tag_and_reject(13, 3); print "prefix len [", net.len, "] not in 8-24 - REJECTING ", net; accept; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS3_1
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(3, 192.0.2.31, "AS3_1") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS3_1";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(3, 192.0.2.31, "AS3_1") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS3_1";

	apply_prepend(3, 192.0.2.31);

	# AS3_1 has been configured with 'prepend_rs_as'
	bgp_path.prepend(999);

	add_noexport_noadvertise(3);

	scrub_communities_out();



	accept;
}

protocol bgp AS3_1 {
	description "AS3_1 client";

	local as 999;
	neighbor 192.0.2.31 as 3;
	rs client;


	passive off;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv4 {
	table master4;

	add paths tx;

	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS3_1;
	export filter announce_to_AS3_1;
	# ---------------------------------------
	};

		}


# AS-SET for AS3_2
function origin_as_is_in_AS3_2_as_set() -> bool {
	return false;
}

# R-SET for AS3_2
function prefix_is_in_AS3_2_as_set() -> bool {
    return false;
}

function next_hop_is_valid_for_AS3_2() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS3_2
	if bgp_next_hop = 2001:db8:1:1::31 then return true;
	return false;
}

function prefix_is_in_AS3_2_blacklist() -> bool
prefix set AS3_2_blacklist_4;
prefix set AS3_2_blacklist_6;
{
    AS3_2_blacklist_4 = [
		# bad network
		3.0.1.0/24{24,32}
    ];
    if net.type = NET_IP4 then
        if net ~ AS3_2_blacklist_4 then return true;
    AS3_2_blacklist_6 = [
		# bad network
		2a03:0:1::/48{48,128}
    ];
    if net.type = NET_IP6 then
        if net ~ AS3_2_blacklist_6 then return true;
	return false;
}


filter receive_from_AS3_2 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 3); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP6) then
		{ tag_and_reject(65535, 3); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS3_2() then
		{ tag_and_reject(5, 3); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 3); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 3 then
		{ tag_and_reject(6, 3); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 3); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [174] then
		{ tag_and_reject(8, 3); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 3); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }

	# Prefix: only IPv6 Global Unicast space allowed
	if net.type = NET_IP6 && !(net ~ [2000::/3+]) then
		{ tag_and_reject(10, 3); print "prefix is not in IPv6 Global Unicast space - REJECTING ", net; accept; }

	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 3); print "prefix is in global blacklist - REJECTING ", net; accept; }

	# Prefix: client's blacklist
	if prefix_is_in_AS3_2_blacklist() then
		{ tag_and_reject(11, 3); print "prefix is in client's blacklist - REJECTING ", net; accept; }

	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 3); print "prefix is bogon - REJECTING ", net; accept; }


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS3_2 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 3); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(17, 48) then
			{ tag_and_reject(13, 3); print "prefix len [", net.len, "] not in 17-48 - REJECTING ", net; accept; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS3_2
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(3, 2001:db8:1:1::31, "AS3_2") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS3_2";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(3, 2001:db8:1:1::31, "AS3_2") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS3_2";

	apply_prepend(3, 2001:db8:1:1::31);

	# AS3_2 has been configured with 'prepend_rs_as'
	bgp_path.prepend(999);

	add_noexport_noadvertise(3);

	scrub_communities_out();



	accept;
}

protocol bgp AS3_2 {
	description "AS3_1 client";

	local as 999;
	neighbor 2001:db8:1:1::31 as 3;
	rs client;


	passive off;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv6 {
	table master6;

	add paths tx;

	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS3_2;
	export filter announce_to_AS3_2;
	# ---------------------------------------
	};

		}


# AS-SET for AS4_1
function origin_as_is_in_AS4_1_as_set() -> bool {
	return false;
}

# R-SET for AS4_1
function prefix_is_in_AS4_1_as_set() -> bool {
    return false;
}

function next_hop_is_valid_for_AS4_1() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS4_1
	if bgp_next_hop = 192.0.2.41 then return true;
	return false;
}



filter receive_from_AS4_1 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 4); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP4) then
		{ tag_and_reject(65535, 4); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS4_1() then
		{ tag_and_reject(5, 4); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 4); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 4 then
		{ tag_and_reject(6, 4); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 4); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [3, 174] then
		{ tag_and_reject(8, 4); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 4); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }


	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 4); print "prefix is in global blacklist - REJECTING ", net; accept; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 4); print "prefix is bogon - REJECTING ", net; accept; }


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS4_1 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 4); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(8, 24) then
			{ tag_and_reject(13, 4); print "prefix len [", net.len, "] not in 8-24 - REJECTING ", net; accept; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS4_1
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(4, 192.0.2.41, "AS4_1") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS4_1";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(4, 192.0.2.41, "AS4_1") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS4_1";

	apply_prepend(4, 192.0.2.41);


	add_noexport_noadvertise(4);

	scrub_communities_out();



	accept;
}

protocol bgp AS4_1 {
	description "AS4_1 client";

	local as 999;
	neighbor 192.0.2.41 as 4;
	rs client;


	passive on;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv4 {
	table master4;


	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS4_1;
	export filter announce_to_AS4_1;
	# ---------------------------------------
	};

		}


# AS-SET for AS4_2
function origin_as_is_in_AS4_2_as_set() -> bool {
	return false;
}

# R-SET for AS4_2
function prefix_is_in_AS4_2_as_set() -> bool {
    return false;
}

function next_hop_is_valid_for_AS4_2() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS4_2
	if bgp_next_hop = 2001:db8:1:1::41 then return true;
	return false;
}



filter receive_from_AS4_2 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 4); print "source != RTS_BGP - REJECTING ", net; accept; }

	if !(net.type = NET_IP6) then
		{ tag_and_reject(65535, 4); print "AFI not enabled for this peer - REJECTING ", net; accept; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS4_2() then
		{ tag_and_reject(5, 4); print "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; accept; }

	# AS_PATH: length
	if bgp_path.len > 6 then
		{ tag_and_reject(1, 4); print "AS_PATH len [", bgp_path.len ,"] longer than 6 - REJECTING ", net; accept; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 4 then
		{ tag_and_reject(6, 4); print "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; accept; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 4); print "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; accept; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [3, 174] then
		{ tag_and_reject(8, 4); print "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; accept; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [666, 777] then
	{ tag_and_reject(15, 4); print "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; accept; }

	# Prefix: only IPv6 Global Unicast space allowed
	if net.type = NET_IP6 && !(net ~ [2000::/3+]) then
		{ tag_and_reject(10, 4); print "prefix is not in IPv6 Global Unicast space - REJECTING ", net; accept; }

	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 4); print "prefix is in global blacklist - REJECTING ", net; accept; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 4); print "prefix is bogon - REJECTING ", net; accept; }


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((65530, 4));
		bgp_large_community.add((999, 65530, 4));

		accept "blackhole filtering request from AS4_2 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 4); print "RPKI, route is INVALID - REJECTING ", net; accept; }

		# Prefix: length
		if !prefix_len_is_valid(17, 48) then
			{ tag_and_reject(13, 4); print "prefix len [", net.len, "] not in 17-48 - REJECTING ", net; accept; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS4_2
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(4, 2001:db8:1:1::41, "AS4_2") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS4_2";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(4, 2001:db8:1:1::41, "AS4_2") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS4_2";

	apply_prepend(4, 2001:db8:1:1::41);


	add_noexport_noadvertise(4);

	scrub_communities_out();



	accept;
}

protocol bgp AS4_2 {
	description "AS4_1 client";

	local as 999;
	neighbor 2001:db8:1:1::41 as 4;
	rs client;


	passive on;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv6 {
	table master6;


	secondary;


	import table on;

	import keep filtered on;

	import filter receive_from_AS4_2;
	export filter announce_to_AS4_2;
	# ---------------------------------------
	};

		}



include "/etc/bird/footer4.local";

include "/etc/bird/footer6.local";

